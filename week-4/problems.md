#Задачи за списъци и accumulate

**Дефинирайте** процедура, която обръща даден списък (non-deep).
```Scheme
(reverse-list '(1 2 3 4)) -> (4 3 2 1)
(reverse-list '(1 3 3 4 2)) -> (2 4 3 3 1)
```

**Дефинирайте** процедура, която проверява дали всички елементи на списък са числа.
integer? ще ви свърши работа.
```Scheme
(all-ints? '(8923 9213 23)) -> #t
(all-ints? '("string" 22 #f)) -> #f
```

**Дефинирайте** процедура, която съединява два списъка
```Scheme
(append '(213 44 "yey") ("yy" #f +)) -> (213 44 "yey" "yy" #f +)
(append '(12 13 14) '("fifteen" "sixteen)) -> (12 13 14 "fifteen" "sixteen")
```

**Дефинирайте** процедура, която намира i-тия елемент на списък
```Scheme
(list-ref '(12 99 24 71) 2) -> 24
(list-ref '("I" "am" "a" "sentence") 1) -> "am"
```

**за** даден списък от низове, дефинирайте процедура, която връща
низовете, разделени с интервал. Празният низ се бележи с "", a два
низа може да съберете със string-append.
```Scheme
(list->string '("This" "is" "Sparta!")) -> "This is Sparta! "
```

##Процедури от по-висок ред за списъци

###map
Map е процедура, която има за аргументи списък и функция. Map връща списък.
Map прави трансформация на списък, чрез функцията, дадена като аргумент.

```Scheme
(map (lambda (x) (+ x 3)) '(1 2 3)) -> (4 5 6)
;Тук трансформираме списъка като към всеки негов елемент прибавяме 3.
(map (lambda (x) (string-append x ".")) '("yey" "omg" "wow")) -> ("yey." "omg." "wow.").
;Тук към всеки елемент залепяме символа "."
```

**Напишете ваша имплементация на map**. Ще помогне да запомните каква е идеята на процедурата.


###filter
Filter е процедура, която приема за аргументи списък и предикат (условие, нещо, което връща #t или #f).
Filter връща списък с всички елементи на оригиналния, които удовлетворяват
предиката.

```Scheme
(filter odd? '(1 2 3 4 5 6 7)) -> (1 3 5 7)
(filter list? '('(1 2 3) 3 4 '("wooow" "right") #f)) -> ((1 2 3) ("wooow" "right"))
```

**Напишете ваша имплементация на filter**. Ще помогне да запомните каква е идеята на процедурата.
